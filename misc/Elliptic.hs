module Elliptic
where

  import Prelude hiding (mod)
  import Modular hiding (add)

  -------------------------------------------------------------------------
  -- Point with Identity
  -------------------------------------------------------------------------
  data Point = O | P (Integer,Integer)
    deriving (Show)

  -------------------------------------------------------------------------
  -- Equality
  -------------------------------------------------------------------------
  instance Eq Point where
    (P (px,py)) == (P (qx,qy)) = px == qx && py == qy
    O == O = True
    _ == _ = False

  -------------------------------------------------------------------------
  -- Point creator taking care of making coordinates modular
  -------------------------------------------------------------------------
  point :: Curve -> (Integer,Integer) -> Point
  point c (x,y) = P (x `mod` p, y `mod` p)
    where p = curM c 

  -------------------------------------------------------------------------
  -- Curve: coefficients a and b and modulo p (for prime numbers)
  --        y^2 == x^3 + ax + b
  -------------------------------------------------------------------------
  data Curve = Curve {
                 curA :: Integer,
                 curB :: Integer,
                 curM :: Integer}
    deriving (Show,Eq)

  -------------------------------------------------------------------------
  -- Get y for x; perhaps better returning 3 ys?
  -------------------------------------------------------------------------
  curveY :: Curve -> Integer -> Integer
  curveY c x = let a = curA c
                   b = curB c
                   p = curM c
                   r = (x^3 + a*x + b) `mod` p
                   y = round (sqrt $ fromIntegral r)
                in y `mod` p

  -------------------------------------------------------------------------
  -- Check if point is on the curve
  --       We are not yet checking for the 3rd y...
  -------------------------------------------------------------------------
  oncurve :: Curve -> Point -> Bool
  oncurve _ O     = True
  oncurve c (P (x,y)) = let z = curveY c x
                         in y == z || y == inverse z p
    where p = curM c
                    
  -------------------------------------------------------------------------
  -- Addition of points
  -------------------------------------------------------------------------
  add :: Curve -> Point -> Point -> Point
  add _ q O = q
  add _ O q = q
  add c q1@(P (x1,y1)) q2@(P (x2,y2)) | isInverse c q1 q2 = O
                                      | otherwise         =
    let l | x1 == x2 &&
            y1 == y2  = 
            let t1 = (3*x1^2 + a)    `mod` p
                t2 = inverse ((2*y1) `mod` p) p
             in t1 * t2
          | otherwise = 
            let t1 =          (y2-y1) `mod` p
                t2 = inverse ((x2-x1) `mod` p) p
             in (t1 * t2) `mod` p
        xr = l^2 - x1 - x2
        yr = l*(x1-xr)-y1 
     in point c (xr, yr)
    where a = curA c
          p = curM c

  -------------------------------------------------------------------------
  -- Multiplication of points
  -------------------------------------------------------------------------
  mul :: Curve -> Integer -> Point -> Point
  mul _ _ O = O
  mul c n p = go n p
    where go 1 q = q
          go i q = go (i-1) (add c p q)

  -------------------------------------------------------------------------
  -- The inverse of a point (x,y) is (x,-y) mod p
  -------------------------------------------------------------------------
  pinverse :: Curve -> Point -> Point
  pinverse _ O = O
  pinverse c (P (x,y)) = point c (x,-y)

  -------------------------------------------------------------------------
  -- Check if a point is the inverse of another
  -------------------------------------------------------------------------
  isInverse :: Curve -> Point -> Point -> Bool
  isInverse _ O O = True
  isInverse c p q = q == pinverse c p

  -------------------------------------------------------------------------
  -- Generate the subgroup of point q
  -------------------------------------------------------------------------
  gen :: Curve -> Point -> [Point]
  gen c q = go q
    where go O = [O]
          go r = r:go (add c r q)

  -------------------------------------------------------------------------
  -- Order of the subgroup generated by point q
  -------------------------------------------------------------------------
  gorder :: Curve -> Point -> Int
  gorder c = length . gen c 

  --------------------------------------------------------------
  -- Test
  --------------------------------------------------------------
  c1 :: Curve
  c1 = Curve 2 2 17 

  p1,p2 :: Point
  p1 = P (5,1)
  p2 = P (6,3)
  
  tstadd :: Point
  tstadd = add c1 p1 p1

  tstgen :: Int -> Point -> [Point]
  tstgen i q = go i q
    where go 0 _ = []
          go n p = p:go (n-1) (add c1 q p)

