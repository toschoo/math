%% =======================================================
%% (c) Tobias Schoofs
%% =======================================================
%% Math 4 Programmers - The Inverse Element
%% =======================================================

% Plain Style
\documentclass[tikz]{scrreprt}

%% ODER: format ==         = "\mathrel{==}"
%% ODER: format /=         = "\neq "
%
%
\makeatletter
\@ifundefined{lhs2tex.lhs2tex.sty.read}%
  {\@namedef{lhs2tex.lhs2tex.sty.read}{}%
   \newcommand\SkipToFmtEnd{}%
   \newcommand\EndFmtInput{}%
   \long\def\SkipToFmtEnd#1\EndFmtInput{}%
  }\SkipToFmtEnd

\newcommand\ReadOnlyOnce[1]{\@ifundefined{#1}{\@namedef{#1}{}}\SkipToFmtEnd}
\usepackage{amstext}
\usepackage{amssymb}
\usepackage{stmaryrd}
\DeclareFontFamily{OT1}{cmtex}{}
\DeclareFontShape{OT1}{cmtex}{m}{n}
  {<5><6><7><8>cmtex8
   <9>cmtex9
   <10><10.95><12><14.4><17.28><20.74><24.88>cmtex10}{}
\DeclareFontShape{OT1}{cmtex}{m}{it}
  {<-> ssub * cmtt/m/it}{}
\newcommand{\texfamily}{\fontfamily{cmtex}\selectfont}
\DeclareFontShape{OT1}{cmtt}{bx}{n}
  {<5><6><7><8>cmtt8
   <9>cmbtt9
   <10><10.95><12><14.4><17.28><20.74><24.88>cmbtt10}{}
\DeclareFontShape{OT1}{cmtex}{bx}{n}
  {<-> ssub * cmtt/bx/n}{}
\newcommand{\tex}[1]{\text{\texfamily#1}}	% NEU

\newcommand{\Sp}{\hskip.33334em\relax}


\newcommand{\Conid}[1]{\mathit{#1}}
\newcommand{\Varid}[1]{\mathit{#1}}
\newcommand{\anonymous}{\kern0.06em \vbox{\hrule\@width.5em}}
\newcommand{\plus}{\mathbin{+\!\!\!+}}
\newcommand{\bind}{\mathbin{>\!\!\!>\mkern-6.7mu=}}
\newcommand{\rbind}{\mathbin{=\mkern-6.7mu<\!\!\!<}}% suggested by Neil Mitchell
\newcommand{\sequ}{\mathbin{>\!\!\!>}}
\renewcommand{\leq}{\leqslant}
\renewcommand{\geq}{\geqslant}
\usepackage{polytable}

%mathindent has to be defined
\@ifundefined{mathindent}%
  {\newdimen\mathindent\mathindent\leftmargini}%
  {}%

\def\resethooks{%
  \global\let\SaveRestoreHook\empty
  \global\let\ColumnHook\empty}
\newcommand*{\savecolumns}[1][default]%
  {\g@addto@macro\SaveRestoreHook{\savecolumns[#1]}}
\newcommand*{\restorecolumns}[1][default]%
  {\g@addto@macro\SaveRestoreHook{\restorecolumns[#1]}}
\newcommand*{\aligncolumn}[2]%
  {\g@addto@macro\ColumnHook{\column{#1}{#2}}}

\resethooks

\newcommand{\onelinecommentchars}{\quad-{}- }
\newcommand{\commentbeginchars}{\enskip\{-}
\newcommand{\commentendchars}{-\}\enskip}

\newcommand{\visiblecomments}{%
  \let\onelinecomment=\onelinecommentchars
  \let\commentbegin=\commentbeginchars
  \let\commentend=\commentendchars}

\newcommand{\invisiblecomments}{%
  \let\onelinecomment=\empty
  \let\commentbegin=\empty
  \let\commentend=\empty}

\visiblecomments

\newlength{\blanklineskip}
\setlength{\blanklineskip}{0.66084ex}

\newcommand{\hsindent}[1]{\quad}% default is fixed indentation
\let\hspre\empty
\let\hspost\empty
\newcommand{\NB}{\textbf{NB}}
\newcommand{\Todo}[1]{$\langle$\textbf{To do:}~#1$\rangle$}

\EndFmtInput
\makeatother
%

\include{cmds}

\begin{document}
\setlength{\parindent}{0pt}
\setlength{\parskip}{8pt}

\chapter{Elliptic Curves} % c10
\section{Geometry Intuition} 
\ignore{
\begingroup\par\noindent\advance\leftskip\mathindent\(
\begin{pboxed}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\mathbf{module}\;\Conid{ECGeometry}{}\<[E]%
\\
\>[B]{}\mathbf{where}{}\<[E]%
\ColumnHook
\end{pboxed}
\)\par\noindent\endgroup\resethooks
}

Before we go on with more theoretical topics,
let us examine another application of the quite
abstract theory of algebra we have studied
in the previous chapters, namely 
elliptic curve cryptography. It should be
mentioned that linear algebra is by far 
not the only topic relevant in this context.
In fact, important aspects of the theory
of elliptic curves require the understanding
of function analysis -- where it actually
comes from -- but here we will focus on 
algebra and group theory.

Elliptic Curves (\acronym{ec}) provide the mathematical
background for variants of public key cryptography.
This kind of cryptography is being developed
since the eighties, but it took a while until it
was accepted by the industry. 
Today, however, it is the 
main public key cryptography scheme around.
Its acceptance was accelerated by the smartphone boom.
In smartphones and other devices with restricited
resources, classic cryptographic schemes are not
very practical. Their drawback is
the computational overhead resulting from key size.
Cryptoanalytic attacks forced classic schemes
to be used with huge keys. To achieve 128-bit security 
with \acronym{rsa}, for instance, we need keys with at least
\num{3072} bits. The same level of security
can be reached with \acronym{ec} cryptography, 
according to known attacks today,
with 256 bits. A huge improvement!

\acronym{ec} cryptography is different from
classic cryptography in various respects.
First, it includes much more math.
That is to say, it does not include 
theory from only one or two branches
of mathematics like number theory
in classic cryptography,
but from many different branches.
This has huge impact on cryptoanalysis.
Hidden attacks may lurk
in apparently remote fields of mathematics
that we did not account for.
However, the theory surrounding \acronym{ec}
is very well understood today and, as said,
it is the mainline cryptography approach today.

Second, the basic means, especially the group
we need for public key cryptography, are
much more ``engineered'' than in classic
cryptography. Classic schemes are based
mainly on modular arithmetic, which was
well known centuries before anyone thought
of this use case. The groups found in modular
arithmetic, in particular the multiplicative
group, was then used to define cryptographic tools.
In elliptic curves, there are no such groups
``by nature''. They are constructed on the
curves with the purpose to use them in cryptography.
Therefore, \acronym{ec} may sometimes feel a bit
artificial. It is important to understand that
the group we define on the curves is defined
voluntarily according to our purpose.
When we speak of \emph{point addition} in this
context, one must not confuse this operation
with the arithmetic operation of addition.
It is something totally different.

Anyway, what are elliptic curves in the first place?
Elliptic curves are polynomials that were
intensively studied in the late $19^{th}$ century,
especially by German mathematician Karl Weierstrass (1815 -- 1897),
who was of huge importance in the sound fundamentation
of analysis. We will meet him again in the third part.
He studied polynomials of the form

\begin{equation}
  y^2 = x^3 + ax + b,
\end{equation}

which is said to be in \emph{Weierstrass form}.
We can easily transform this equation
into a form that looks more like something that
can be computed, namely:

\begin{equation}
  y = \sqrt{x^3 + ax + b}.
\end{equation}

But be careful! Weierstrass polynomials are not functions,
at least not in $\mathbb{R}$, since there is not exactly
one $y$ for each $x$. When the expression $x^3 + ax + b$
becomes negative, there is, in the world of real numbers, 
no solution for the right-hand side of the equation.

This is quite obvious, when we look at the geometric
interpretation of that polynomial. It looks -- more or less --
like in the following sketch:

\begin{center}
\begin{tikzpicture}
   \draw [<->] (-3,0) -- (3,0);
   \draw [<->] (0,-3) -- (0,3);
   \draw [teal, 
scale=0.5,domain=-1.769292354238631:3,variable=\x,smooth,samples=250]
       plot ({\x}, {sqrt(\x*\x*\x - 2*\x + 2)});
   \draw [teal, 
scale=0.5,domain=-1.769292354238631:3,variable=\x,smooth,samples=250]
       plot ({\x}, {-sqrt(\x*\x*\x - 2*\x + 2)});
\end{tikzpicture}
\end{center}

The exact shape depends on the coefficients $a$ and $b$.
The bubble on the left may sometimes be a circle or ellipse
completely separated from the ``tail'' on the right;
it may, in other cases, be less clearly distinguished
from the tail on the right, forming just a tiny bulge in the tail.

In any case, the curve ``ends'' on the left-hand side
for some $x < 0$. More precisely, it ends where 
the absolute value of $x^3$, for a negative
value, becomes greater than $ax + b$. Then, the whole 
expression becomes negative and no real square root corresponds to it.

We will now start to construct a group on this kind of curves.
We call it an \emph{additional group}, but be aware that this
is not addition in the sense of the arithmetic operation.
It has nothing to do with that! It is a way to combine points
with each other that can be captured in a  -- more or less -- 
simple formula. We will start by giving a geometric interpretation
of this operation. This will help getting an intuition.
But, again, be aware that we are not dealing with geometry.
We will soon deviate from geometry and talk about curves
in a quite abstract way.

The following sketch shows an elliptic curve
with three points $P$, $Q$ and $R$,
all coloured in red.
These points are in the relation
$P + Q = R$.

% ------------------------------------------------------------------------
% Point Addition (distinct points)
% ------------------------------------------------------------------------
\begin{center}
\begin{tikzpicture}
   \draw [<->] (-4,0) -- (4,0);
   \draw [<->] (0,-4) -- (0,4);
   \draw [teal, 
          scale=0.75,domain=-1.769292354238631:3.5,variable=\x,smooth,samples=250]
       plot ({\x}, {sqrt(\x*\x*\x - 2*\x + 2)});
   \draw [teal, 
          scale=0.75,domain=-1.769292354238631:3.5,variable=\x,smooth,samples=250]
       plot ({\x}, {-sqrt(\x*\x*\x - 2*\x + 2)});
   \draw [red,fill=red] (-1.05,1.1) circle (1.5pt);
   \node [red,font=\small,anchor=south east] (p) at (-1.2,0.9) {P};
   \draw [red,fill=red] (0.32,-0.82) circle (1.5pt);
   \node [red,font=\small,anchor=north east] (q) at (0.5,-0.95) {Q};
   \draw [gray, 
          scale=0.75,domain=-3.5:3.5,variable=\x,smooth,samples=15]
         plot ({\x}, {-1.407*\x-0.5});
   \draw [black,fill=black] (2.17,-3.42) circle (1.5pt);
   \node [font=\small,anchor=south west] (q) at (2.2,-3.4) {R'};
   \draw [dotted] (2.17,-3.9) -- (2.17,3.9);
   \draw [red,fill=red] (2.17,3.42) circle (1.5pt);
   \node [red,font=\small,anchor=north west] (q) at (2.2,3.5) {R};
\end{tikzpicture}
\end{center}

When adding two points $P$ and $Q$ on an elliptic curve, 
we draw a straight line through them (the grey one).
From the nature of the elliptic curve, it is obvious
that the straight line will meet the curve once again.
At that intersection, we draw a helper point, $R'$.
The we reflect this point across the $x$-axis, \ie
we draw another line (the dotted one) that goes
straight up crossing $R'$. This line will meet the curve
again, namely at a point with the same $x$ coordinate,
but with the inverse of the $y$ coordinate $-y$.
That point is $R$, the result of $P + Q$.

You see that this operation has in fact nothing to do
with arithmetic addition. It is an arbitrary construction
to relate three points.
Nevertheless, it is carefully designed to give rise
to a group based on this operation, as we will see later.

For the moment, our main question is how can we
compute $R$ from $P$ and $Q$. We start by computing
the straight line. A straight line is defined by
a formula of the form

\begin{equation}
y = mx + c,
\end{equation}

where $m$ is the slope and $c$ the $y$-intercept.
What we need to do now is to find the third point,
$R'$, which, like $P$ and $Q$, lies on both,
the straight line and the elliptic curve.
To find such a point, we set the two formulas
equal. Since an elliptic curve is defined as

\begin{equation}  
y^2 = x^3 + ax + b, 
\end{equation}  

we can say

\begin{equation}  
(mx + c)^2 = x^3 + ax + b.
\end{equation}

By subtracting $(mx+c)^2$ from both sides, we get

\begin{equation}  
x^3 + ax + b - (mx + c)^2 = 0.
\end{equation}

Using the binomial theorem 
we can expand this to

\begin{equation}  
x^3 - m^2x^2 - 2mxc - c^2 + ax + b = 0.
\end{equation}

We already know two points, where this equation is fulfilled,
namely $x_P$ and $x_Q$. This means that these values
are roots of the above equation. We can hence use them for
factoring that equation into $(x-x_P)(x-x_Q)\Psi$,
where $\Psi$ is yet another factor. But we know even more.
We just have to look at the sketch above to see that there
are three roots and, hence, three factors. 
We, therefore, have $\Psi = x - x_{R'}$ and conclude that

\begin{equation}  
x^3 - m^2x^2 - 2mxc - c^2 + ax + b = (x-x_P)(x-x_Q)(x-x_{R'}).
\end{equation}

From here it is quite simple. 
We just apply the trick of the 
\emph{opposite sum of the roots}
and get

\begin{equation}  
m^2 = x_P + x_Q + x_{R'},
\end{equation}

which we can easily transform to 

\begin{equation}  
x_{R'} = m^2 - x_P - x_Q. 
\end{equation}

Since $R$, the point we are finally looking for,
is the reflection of $R'$ across the $x$-axis,
we have $x_{R} = x_{R'}$, \ie\ the points have
the same $x$-coordinate.

Computing $y_{R'}$ is again quite simple.
The points $P$ and $R'$ are on the same 
straight line. The $y$-values on a straight line
increase at a constant rate. So, we compute
the value $y$ should grow travelling on the segment
between $x_P$ and $x_R$, which is
$m(x_R - x_P)$ and add this to the 
already known $y$-value at point $P$:

\begin{equation}
y_{R'} = y_P + m(x_R - x_P).
\end{equation}

Now we compute $y_R$, the $y$-coordinate
of the reflections of $R'$ across the $x$-axis,
which is simply $-y$. 
Alternatively, we can compute that 
value directly by rearranging the 
equation to

\begin{equation}
y_R = m(x_P - x_R)-y_P.
\end{equation}

The final piece missing now is the slope, $m$,
which can  be expressed as a fraction:

\begin{equation}
m = \frac{y_Q - y_P}{x_Q - x_P}.
\end{equation}

With this equation, however,
we get into trouble. Everything is fine,
when we assume that we add two distinct
points $P$ and $Q$. But if we have
$P = Q$, \ie\ if we want to add a point
to itself, then the denominator of
the above fraction becomes negative.
That, clearly, is to be avoided.

To avoid that, we use, instead of a secant line
that intersects the curve, the tangent line at
point $P$, which, as we already know, measures 
the slope of the curve at $P$.
Geometrically, this corresponds to the following sketch:

% ------------------------------------------------------------------------
% Point Doubling
% ------------------------------------------------------------------------
\begin{center}
\begin{tikzpicture}
   \draw [<->] (-4,0) -- (4,0);
   \draw [<->] (0,-4) -- (0,4);
   \draw [teal, 
          scale=0.75,domain=-1.769292354238631:3.5,variable=\x,smooth,samples=250]
       plot ({\x}, {sqrt(\x*\x*\x - 2*\x + 2)});
   \draw [teal, 
          scale=0.75,domain=-1.769292354238631:3.5,variable=\x,smooth,samples=250]
       plot ({\x}, {-sqrt(\x*\x*\x - 2*\x + 2)});
   \draw [red,fill=red] (-0.9,1.25) circle (1.5pt);
   \node [red,font=\small,anchor=south east] (p) at (-1.2,0.9) {P};
   \draw [gray, 
          scale=0.75,domain=-4.5:3.5,variable=\x,smooth,samples=15]
         plot ({\x}, {0.7*\x+2.5});
   \draw [red,fill=red] (2.17,-3.42) circle (1.5pt);
   \node [red,font=\small,anchor=south west] (q) at (2.2,-3.4) {R};
   \draw [dotted] (2.17,-3.9) -- (2.17,3.9);
   \draw [black,fill=black] (2.17,3.42) circle (1.5pt);
   \node [black,font=\small,anchor=north west] (q) at (2.2,3.5) {R'};
\end{tikzpicture}
\end{center}

Here, we draw the tangent line at $P$.
Where the tangent line intersects the curve again,
we draw the helper point $R'$. We reflect it across
the $x$-axis and obtain the point $R = P+P = 2P$.

As you hopefully remember, the slope of a curve 
at a given point can be calculated with the derivative of that curve.
We will apply that derivative trick to get the tangent line
at $P$. This task, however, is a bit more difficult than
for the trivial cases we have seen so far.
Until now, we have seen derivatives of simple functions like
$f(x) = x^2$, whose derivative is $f'(x) = 2x$.
Now, we have the equation

\begin{equation}
y^2 = x^3 + ax + b.
\end{equation}

We can interpret this equation as an application of
two different functions. The first function, say, $g$,
is $g(x) = x^3 + ax + b$. The second function, $f$, is
$f(x) = \sqrt{x} = x^{\frac{1}{2}}$.

For such cases, we have the \term{chain rule},
which we will discuss more thoroughly in part 3.
The chain rule states that the derivative of
the composition of two functions is

\begin{equation}
(f \circ g)' = (f' \circ g) \times g'.
\end{equation}

That is, the derivative of the composition 
of two functions $f$ and $g$ is 
the derivative of $f$ applied on $g$ times the
derivative of $g$. Let us figure out 
what the derivatives of our $f$ and $g$ are. 
The derivative of $g$ is easy:

\[
g'(x) = 3x^2 + a
\]

A bit more difficult is $f'$. If $f(x) = x^\frac{1}{2}$,
then 

\[
f'(x) = 
\frac{1}{2}x^{\frac{1}{2}-1} = 
\frac{1}{2}x^{-\frac{1}{2}}  =
\frac{1}{2x^{\frac{1}{2}}}. 
\]

Now, we apply this to the result of $g(x)$,
which we can elegantly present as $y^2$. 
If we plug $y^2$ into the equation above,
we get 

\[
\frac{1}{2y^{2\times\frac{1}{2}}} = \frac{1}{2y}.
\]

We now multipy this by $g'$ and get 

\[
\frac{3x^2 + a}{2y}.
\]

When we use this formula for $x=x_P$,
we get the formula to compute $m$:

\begin{equation}
m = \frac{3x_P^2 + a}{2y_P}.
\end{equation}

So, we finally have an addition formula
that covers both cases, $P \neq Q$ and $P = Q$:

\begin{equation}
x_R = \begin{cases}
        m^2 - x_P - x_Q & \textrm{if $x_P \neq x_Q$}\\
        m^2 - 2x_P      & \textrm{otherwise}
      \end{cases}
\end{equation}

and

\begin{equation}
y_R = m(x_P-x_R) - y_P,
\end{equation}

where

\begin{equation}
m = \begin{cases}
      \frac{y_Q - y_P}{x_Q - x_P} & \textrm{if  $x_P \neq x_Q$}\\[10pt]
      \frac{3x_P^2 + a}{2y_P}     & \textrm{otherwise}.
    \end{cases}
\end{equation}
\section{Projective Geometry} 
\ignore{
\begingroup\par\noindent\advance\leftskip\mathindent\(
\begin{pboxed}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\mathbf{module}\;\Conid{ECProjective}{}\<[E]%
\\
\>[B]{}\mathbf{where}{}\<[E]%
\ColumnHook
\end{pboxed}
\)\par\noindent\endgroup\resethooks
}

To complete the construction of the group 
of points on an elliptic curve, we still
have to define the identity and the inverse.
To do this we make a detour through the
beautiful art of \emph{projective geometry}.
To be honest, we do not need too many
concepts of projective geometry in practice.
But with an intuitive understanding of those concepts
the jargon common in \acronym{ec} cryptography
becomes much clearer. Besides, projective geometry
is really a beautiful part of mathematics
worth studying whether we need it for \acronym{ec}
or not.

Geometry is often concerned with difference and
equality of quantities like length and angle.
In this type of geometry, called \emph{metric geometry},
one studies properties of objects under transformations
that do not change the length and angle.
A typical statement is, for instance, that two triangles
are congruent (and hence equal), when one of them
can be be as a roation or displacement of the other.
The triangles below,
for instance, are all congruent to each other:

% ------------------------------------------------------------------------
% Tumbling triangle
% ------------------------------------------------------------------------
\begin{center}
\begin{tikzpicture}
\draw (0,0) -- (2,0) -- (1,1);
\draw (0,0) -- (1,1);
\draw (3,0) -- (4.414,0) -- (4.414,1.414);
\draw (3,0) -- (4.414,1.414);
\draw (5.5,1) -- (7.5,1) -- (6.5,0);
\draw (5.5,1) -- (6.5,0); 
\draw (8.5,0) -- (9.941,0) -- (8.5,1.414);
\draw (8.5,0) -- (8.5,1.414);
\end{tikzpicture}
\end{center}

In fact, we could say it is four times
the same triangle tumbling around.
We are now looking at what remains 
from metric geometry, when we disregard
length and angle as first-class properties of objects.
One way to do so is by looking at logic configurations
according to some basic notion, such as that of parallel lines.
This gives rise to what is called \emph{affine geometry}.
Another way is to look at properties invariant under 
projective transformations and this is indeed
what projective geometry does.

The triangles above are, as you can see, drawn on a plane.
We could now take another plane, just as we would grab a
piece of paper, and \emph{project} the points on the first
plane onto the second plane. The two planes do not need
to fulfil any specific configuration. They may be parallel
to each other or they may not. 
They may be arranged in any configuration
relative to some orientation in the surrounding space. 
Indeed, we are now looking at transformations
of two-dimensional figures on two-dimensional planes.
But the transformations are created by projecting one figure
through three-dimensional space onto another plane.
Of course, we can generalise this to $n$-dimensional planes
in an $n+1$-dimensional space.
But that would be far beyond our needs. 

Projective transformations relate points on one plane,
let us call it $\pi$, to points on the other plane, $\pi\prime$,
by drawing a straight line that relates both points with yet
another point, which, in \emph{central projection}, is called
the centre and is identical for all points we project from
$\pi$ to $\pi\prime$. We can also choose to use 
\emph{parallel projection}, where points are projected 
by parallel lines, each one having its own projection ``centre''.
As we will see later, in projective geometry,
that is not a significant difference.
The latter is just a special case of the first resulting
from a very specific choice of the central point.

The following sketch shows a projection from $\pi$,
the lower plane, to $\pi\prime$ using central projection
with $O$ being the central point: 

% ------------------------------------------------------------------------
% Projective Planes
% ------------------------------------------------------------------------
\begin{center}
\begin{tikzpicture}
   % pi'
   \draw (0,0) -- (1,2) -- (3,2) -- (4,0) -- (0,0);
   \node [font=\small,anchor=north east] (pi2) at (0,0) {$\pi\prime$};

   % pi
   \draw (2,-1) -- (1,0);
   \draw [dotted] (1,0) -- (0.33,0.66); 
   \draw (0.33,0.66) -- (0,1);
   \draw (0,1) -- (0.66,1.33); % (2,2);
   \draw [dotted] (0.66,1.33) -- (2,2);
   \draw (2,-1) -- (3,0); 
   \draw [dotted] (3,0) -- (3.66,0.66);
   \draw (3.66,0.66) -- (4,1);
   \draw (4,1) -- (3.33,1.33);
   \draw [dotted] (3.33,1.33) -- (2,2);
   \node [font=\small,anchor=north east] (pi) at (2,-1) {$\pi$};

   % O
   \draw [red,fill=red] (2.5,4.5) circle (1.5pt);
   \node [font=\small,anchor=south west] (o) at (2.5,4.5) {O};

   % on pi
   \draw [gray,fill=gray] (1.2,0.8) circle (1.5pt);
   \node [gray, font=\tiny ,anchor=north west] (a) at (1,0.8) {A};
   \draw [gray,fill=gray] (2.5,1.2) circle (1.5pt);
   \node [gray, font=\tiny ,anchor=north west] (b) at (2.5,1.2) {B};
   \draw [gray,fill=gray] (2,0.6) circle (1.5pt);
   \node [gray, font=\tiny ,anchor=north west] (c) at (2.1,0.6) {C};
   \draw [gray,dotted] (1.2,0.8) -- (2.5,1.2);
   \draw [gray,dotted] (1.2,0.8) -- (2,0.6);
   \draw [gray,dotted] (2,0.6) -- (2.5,1.2);

   % on pi'
   \draw [fill=teal,teal] (1.5,1.65) circle (1.5pt);
   \node [teal,font=\tiny ,anchor=south east] (a2) at (1.4,1.6) {$A\prime$};
   \draw [fill=teal,teal] (2.5,1.8) circle (1.5pt);
   \node [teal,font=\tiny ,anchor=south west] (b2) at (2.5,1.6) {$B\prime$};
   \draw [fill=teal,teal] (2.1,1.32) circle (1.5pt);
   \node [teal,font=\tiny ,anchor=east] (c2) at (2,1.2) {$C\prime$};
   \draw [teal] (1.5,1.65) -- (2.5,1.8);
   \draw [teal] (1.5,1.65) -- (2.1,1.32);
   \draw [teal] (2.5,1.8) -- (2.1,1.32);

   % projection lines
   \draw [dotted,red]  (1.2,0.8) -- (2.5,4.5);
   \draw [dotted,red]  (2.5,1.2) -- (2.5,4.5);
   \draw [dotted,red]  (2,0.6) -- (2.5,4.5);
   
\end{tikzpicture}
\end{center}

There are, on $\pi$, three points, $A$, $B$ and $C$,
which form a triangle. The points are projected
on $\pi\prime$ along the lines relating each of the points
with $O$. We see that all points on $\pi$ appear on $\pi\prime$
and we see that one of the properties that are preserved
is that on both planes these points form a triangle pointing
roughly in the same direction. The triangles, however, are of 
different size and, due to different arrangement of the planes
in space, the shape of the original triangle is distorted on
$\pi\prime$.

Projective geometry studies properties that remain
unchanged under projection. Such properties are essential
for us recognising projected shapes. It is therefore
no surprise that projective geometry was originally
introduced to mathematics by math-literate painters,
in particular Renaissance artists 
like Leonardo da Vinci (1452 -- 1519) and
Albrecht DÃ¼rer (1471 -- 2528). 
Today projective geometry is ubiquitous. It is used
in all kinds of image processing and image recognition.
It is widely used in digital cameras for instance,
but also in many other kinds of applications.

The founding father of the mathematical discipline
of projective geometry was the French 
engineer, architect and mathematician 
Girard Desargues (1591 -- 1661). Desargues formulated
and proved \emph{Desargues' theorem}, one of the first
triumphs of projective geometry. The theorem states that,
if two triangles are situated such that the straight lines
joining corresponding vertices of the triangles intersect
in a point $O$, then the corresponding sides, when
extended, will intersect in three points that are all
on the same line. Here is a sketch to make that
a bit clearer:

% ------------------------------------------------------------------------
% Desargues' Theorem
% ------------------------------------------------------------------------
\begin{center}
\begin{tikzpicture}[scale=1.5]
   \draw [gray,fill=gray] (0,5) -- (1,3) -- (2,4) -- (0,5);
   \draw [gray,fill=gray] (3,4.357) -- (1.6,3.05) -- (3.5,3.85) -- (3,4.357);

   \node [gray,font=\tiny,anchor=east] (a) at (0,5) {A};
   \node [gray,font=\tiny,anchor=east] (b) at (1,3) {B};
   \node [gray,font=\tiny ,anchor=south] (c) at (2,4) {C};

   \node [gray,font=\tiny ,anchor=south] (a2) at (3,4.37) {$A\prime$};
   \node [gray,font=\tiny ,anchor=north] (b2) at (1.6,3.05) {$B\prime$};
   \node [gray,font=\tiny ,anchor=west] (c2) at (3.5,3.85) {$C\prime$};

   \draw [gray] (1,3) -- (1.5,2); 
   \draw [gray] (1,3) -- (0,2);
   \draw [gray] (2,4) -- (6,2);
   \draw [gray] (1.6,3.05) -- (0.475,2);
   \draw [gray] (1.6,3.05) -- (0,2.376);
   \draw [gray] (3.5,3.85) -- (5.324,2);

   \draw [red] (1.175,2.65) circle (1.5pt);
   \draw [red] (0.65 ,2.65) circle (1.5pt); 
   \draw [red] (4.69 ,2.65) circle (1.5pt); % there must be some (rounding?) mistake
                                            % the point is (4.676,2.662).

   \draw [red,fill=red] (7,3.5) circle (1.5pt);
   \node [red,font=\small,anchor=north west] (o) at (7,3.5) {O};

   \draw [teal] (0,2.65) -- (7,2.65);
   \node [teal,font=\small,anchor=north east] (l) at (6.5,2.7) {l};

   \draw [dotted,red] (0,5) -- (7,3.5);
   \draw [dotted,red] (1,3) -- (7,3.5);
   \draw [dotted,red] (2,4) -- (7,3.5);
\end{tikzpicture}
\end{center}

The dotted lines capture the theorem's precondition:
corresponding vertices of the triangles 
lie on lines that intersect in one point $O$.
The gray lines extend the sides of the triangles and
the pairs of corresponding sides all intersect, each side
with its corresponding side, on the same line $l$.

The theorem looks quite simple; after all, it contains
only straight lines. It is nevertheless quite difficult to prove
with means of metric geometry.
If we consider the two triangles being on different planes, however,
and one the projection of the other, the argument suddenly
becomes very easy.

We first note that all points and lines making up one triangle 
are located on one plane. We then observe 
that each of the lines that relate one edge of one triangle
with one edge of the other triangle,
for instance $\overline{AA\prime}$ or $\overline{BB\prime}$,
also lie in a plane, otherwise we could not draw these lines.
But that means that $A$ and $A\prime$, $B$ and $B\prime$ and
$C$ and $C\prime$ as well as $O$ all lie in the same plane. 
Therefore the lines $\overline{AB}$ and $\overline{A\prime B\prime}$
must meet somewhere. 
Since the triangles are in separate planes, the two planes
must meet somewhere too and there, 
where the planes meet, there must
be the intersection of all those lines. Two planes, however,
meet in a line and, since they have exactly one line in common, 
it must be on that line where all the other lines
itersect. 

Note that this proof works with reasoning according to the logic
of plane and space alone, which makes it concise and elegant,
but also quite subtle. Indeed, I hesitate to put ``$\square$'' to the
end of the proof. In fact, there is a flaw in it.
The proof only works when the planes 
are not parallel to each other!
When we project the triangle onto a plane parallel to the first one,
then these two planes will certainly never meet -- and that 
crashes the proof.

That is a very typical situation in projective geometry.
Theorems and proofs would look very nice and clean,
had we not always those exceptions of parallel lines!
In fact, there are even points on the original plane that will never appear
in the projection, because their projective line is
parallel to the second plane. Point $A$ in the following
configuration, for instance, with the projective centre at $O$
will never show up on the target plane: 

% ------------------------------------------------------------------------
% Parallel Plane
% ------------------------------------------------------------------------
\begin{center}
\begin{tikzpicture}
   \draw (0,0) -- (2,2) -- (3,2) -- (4,0) -- (0,0);
   \node [font=\small,anchor=east] (pi) at (0,0) {$\pi$};
   \draw (4,0) -- (4,4) -- (3,3) -- (3,2);
   \node [font=\small,anchor=north west] (pip) at (4,4) {$\pi\prime$};

   \draw [red,fill=red] (2.5,4.5) circle (1.5pt);
   \node [red,font=\small,anchor=south east] (o) at (2.5,4.5) {O};

   \draw [fill=black] (2.5, 1.1) ellipse (1.5pt and 1pt);
   \node [font=\small,anchor=east] (a) at (2.5,1.1) {A};

   \draw [red,dotted] (2.5,1.1) -- (2.5,4.5);

   
   % \draw [dotted] (1,2) -- (2,4);
   % \draw [dotted] (3,2) -- (2,4);
   % \draw [dotted] (2,4) -- (4,4);
\end{tikzpicture}
\end{center}

Projective geometry could be very clean and nice, was there not
that issue of parallel lines. It comes into the way in every
axiom and every theorem and every proof. Therefore, mathematicians
tried to come around it. 
They did so by the following thought experiment.
If we have two intersecting lines and now start to
rotate them slowly so that they approximate the configuration
where they are parallel to each other,
the point of intersection moves farther away towards
infinity. We could then assume that all lines intersect.
There is then nothing special about parallel lines.
They intersect too, but do so very far away, \viz
at infinity. This way, we extend the concept
of point and line by adding one point to each line,
namely the point where this line and 
all lines parallel to it
intersect. That point is then said \emph{
to be at infinity}.

This trick to extend a concept is very similar 
to how we extended natural numbers to
integers by adding a sign. Suddenly, we had a solution
for problems that were unsolvable before,
namely subracting a number from a smaller one.

Out there, at infinity, there are now many points,
each one the intersection of an infinite number 
of parallel lines crossing it. Of course, we now
can draw a line through all these points at infinity,
the \emph{line at infinity}. That is where the planes 
in the proof of Desargues' theorem intersect in
the case where they are parallel to each other.
We then only have to prove that, if one pair of
lines intersect at infinity, the other two as well
intersect at infinity.

It is perhaps worth to emphasis that this is not
the result of observation of physical reality.
Nobody has ever seen two lines intersecting at
infinity. It is not a statement about physics at all.
It is an axiom that we assume, because it makes 
reasoning in projective geometry much easier.

This handling of parallelism separates the two 
approaches to geometry, affine and projective
geometry. Indeed, in affine geometry the notion
of parallel lines is central. Many problems
in that branch of mathematics are centred 
on the implications
of one line being parallel to another or not.
In projective geometry, by contrast, two lines
being parallel to each other is nothing special.
It just means that their point of intersection
is very far away. 
We will discuss this again later
in more detail.

Let us now come back to elliptic curves.
Where do parallel lines play a role in our
addition formula? Well, the line to reflect
a point across the $x$-axis is parallel to
the $y$-axis and all such lines are parallel 
to each other. In projective terminology,
all these lines intersect at infinity.
In other words, a point and its reflection
define a line that intersects with the 
reflection lines of all other points at
the point at infinity.
We can sketch that like this:

\begin{center}
\begin{tikzpicture}
   \draw [<->] (-4,0) -- (4,0);
   \draw [<->] (0,-4) -- (0,4);
   \draw [teal, 
          scale=0.75,domain=-1.769292354238631:3.5,variable=\x,smooth,samples=250]
       plot ({\x}, {sqrt(\x*\x*\x - 2*\x + 2)});
   \draw [teal, 
          scale=0.75,domain=-1.769292354238631:3.5,variable=\x,smooth,samples=250]
       plot ({\x}, {-sqrt(\x*\x*\x - 2*\x + 2)});
   \draw [red,fill=red] (-1.05,1.1) circle (1.5pt);
   \node [red,font=\small,anchor=south east] (p) at (-1.2,0.9) {P};
   \draw [red,fill=red] (-1.05,-1.1) circle (1.5pt);
   \node [red,font=\small,anchor=north east] (pp) at (-1.1,-0.9) {P'};
   \draw [gray] (-1.05,4) -- (-1.05,-4.5);

   \draw [red,fill=red] (2.17,-3.42) circle (1.5pt);
   \node [red,font=\small,anchor=south west] (r) at (2.2,-3.4) {R};
   \draw [red,fill=red] (2.17,3.42) circle (1.5pt);
   \node [red,font=\small,anchor=north west] (rp) at (2.2,3.5) {R'};
   \draw [gray] (2.17,-4.5) -- (2.17,4);

   \draw [dotted] (2.17,4) arc (0:180:1.61);
   \draw [red,fill=red]  (0.56,5.6) circle (1.5pt);
   \node [red,font=\small,anchor=south west] (o) at (0.4,5.7) {$\infty$}; % {$\mathcal{O}$};
\end{tikzpicture}
\end{center}

Usually, when we add two points on an elliptic curve,
we search for a third intersection of the straight line 
through the points with the curve 
and then reflect that point across
the $x$-axis. What should happen,
when we do this with a point and its reflection
across the $x$-axis? It is indeed not quite clear,
because we will not find any other intersection of line
and curve. However, if we continue to travel
along the line, we would at some point (``at infinity'')
reach the intersection of the line we are travelling
with all other lines parallel to the $y$-axis.
The idea now is to define addition of a point $P$
with its reflection $P'$ in such a way that
$P + P'$ is precisely that point, which,
in the context of elliptic curves, we call $\mathcal{O}$.
So we add that point $\mathcal{O}$ to the curve
and decide -- deliberately -- that this point is
the additive identity. For any point $P$ on the curve,
it then holds that $P + \mathcal{O} = P$.
The point $P'$, for which $P + P' = \mathcal{O}$,
\ie\ the reflection of $P$ across the $x$-axis,
is in consequence the inverse of $P$.

Note that there is no deeper mathematics involved here
that would directly lead to a formula that we could apply
to ``automatically'' generate the result
$P + P' = \mathcal{O}$. Instead, we have
to consider this case as well as $P + \mathcal{O} = P$
explicitly in the addition formula.

But why do we reflect at all, when adding two points?
That is because, otherwise, addition would
be quite boring. Suppose we added without reflection.
Then addition would go $P + Q = R'$ and the 
reverse additions $R' + Q = P$ and
$R' + P = Q$ would just lead back to where we started.
This would be true for any three points 
in such an additional constellation, because the three points
are on the same straight line. If we go forward prolonging
the line $\overline{PQ}$, we find $R'$. If we go backward
prolonging the line $\overline{R'Q}$, we find $P$, or,
if we draw the line $\overline{R'P}$, we find $Q$ in the middle.
Even if such a rule
could ever lead to a group, there would be no 
generators of the group. A generator is a point
that repeatedly added to itself creates the whole group.
But leaving reflection out, the subsequent addition of
a point $P$ would give raise to a sequence like
$P,2P,P,2P,P,\dots$, which, certainly, is not a group.
\section{EC modulo a Prime} 
\ignore{
\begingroup\par\noindent\advance\leftskip\mathindent\(
\begin{pboxed}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\mathbf{module}\;\Conid{ECModulo}{}\<[E]%
\\
\>[B]{}\mathbf{where}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\mathbf{import}\;\Conid{Prelude}\;\Varid{hiding}\;(\Varid{mod}){}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\mathbf{import}\;\Conid{\Conid{System}.Random}\;(\Varid{randomRIO}){}\<[E]%
\\[\blanklineskip]%
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\mathbf{import}\;\Conid{Prime}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\mathbf{import}\;\Conid{Modular}\;\Varid{hiding}\;(\Varid{add},\Varid{mul},\Varid{mDiv},\Varid{mod}){}\<[E]%
\ColumnHook
\end{pboxed}
\)\par\noindent\endgroup\resethooks
}

It was already indicated that the geometry exercises
in the previous sections had the sole purpose of giving
an intuition. EC Cryptography does not take place
in the continuous universe. It does take place in modular arithmetic
with integers and, hence, in a discrete world. 
This is a disruptive turning point,
since we cannot plot a curve and search for a point
in the Cartesian plane anymore. As we will see
examining points of a curve modulo some number
these points are not located on anything even close to the curves
we saw in the previous sections.
One could say that we adopt the algebra of elliptic curves,
but drop the geometry.

Let us start with a data type.
We define an elliptic curve as

\begin{minipage}{\textwidth}
\begingroup\par\noindent\advance\leftskip\mathindent\(
\begin{pboxed}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{5}{@{}>{\hspre}l<{\hspost}@{}}%
\column{18}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[3]{}\mathbf{data}\;\Conid{Curve}\mathrel{=}\Conid{Curve}\;\{\mskip1.5mu {}\<[E]%
\\
\>[3]{}\hsindent{15}{}\<[18]%
\>[18]{}\Varid{curA}\mathbin{::}\Conid{Natural},{}\<[E]%
\\
\>[3]{}\hsindent{15}{}\<[18]%
\>[18]{}\Varid{curB}\mathbin{::}\Conid{Natural},{}\<[E]%
\\
\>[3]{}\hsindent{15}{}\<[18]%
\>[18]{}\Varid{curM}\mathbin{::}\Conid{Natural}\mskip1.5mu\}{}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}\mathbf{deriving}\;(\Conid{Show},\Conid{Eq}){}\<[E]%
\ColumnHook
\end{pboxed}
\)\par\noindent\endgroup\resethooks
\end{minipage}

This type describes a curve in terms of its coefficient
$a$ and $b$ and in terms of the modulus.
When we consider only curves of the form

\begin{equation}
y^2 = x^3 + ax + b,
\end{equation}

the definition given by the type is sufficient.
There are other curves, though, for instance this one:

\begin{equation}
y^2 = x^3 + ax^2 + bx + c,
\end{equation}

but we do not consider them in this humble introduction.

For the modulus, either a (huge) prime is used
or a (huge) power of 2. Again, we do not consider
powers of 2. 

Now we define the notion of ``point'':

\begin{minipage}{\textwidth}
\begingroup\par\noindent\advance\leftskip\mathindent\(
\begin{pboxed}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{5}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[3]{}\mathbf{data}\;\Conid{Point}\mathrel{=}\Conid{O}\mid \Conid{P}\;\Conid{Natural}\;\Conid{Natural}{}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}\mathbf{deriving}\;(\Conid{Eq}){}\<[E]%
\ColumnHook
\end{pboxed}
\)\par\noindent\endgroup\resethooks
\end{minipage}

and make it an instance of \ensuremath{\Conid{Show}} to get a more
pleasant visualiation:

\begin{minipage}{\textwidth}
\begingroup\par\noindent\advance\leftskip\mathindent\(
\begin{pboxed}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{5}{@{}>{\hspre}l<{\hspost}@{}}%
\column{18}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[3]{}\mathbf{instance}\;\Conid{Show}\;\Conid{Point}\;\mathbf{where}{}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}\Varid{show}\;\Conid{O}{}\<[18]%
\>[18]{}\mathrel{=}\text{\tt \char34 O\char34}{}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}\Varid{show}\;(\Conid{P}\;\Varid{x}\;\Varid{y})\mathrel{=}\text{\tt \char34 (\char34}\plus \Varid{show}\;\Varid{x}\plus \text{\tt \char34 ,\char34}\plus \Varid{show}\;\Varid{y}\plus \text{\tt \char34 )\char34}{}\<[E]%
\ColumnHook
\end{pboxed}
\)\par\noindent\endgroup\resethooks
\end{minipage}

Note that we explicitly define $\mathcal{O}$,
the identity, to which we will have to refer
explicitly in addition and other operations
on points later. 

We also define convenience getters for the 
point coordinates:

\begin{minipage}{\textwidth}
\begingroup\par\noindent\advance\leftskip\mathindent\(
\begin{pboxed}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{11}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[3]{}\Varid{xco}\mathbin{::}\Conid{Point}\to \Conid{Natural}{}\<[E]%
\\
\>[3]{}\Varid{xco}\;\Conid{O}\mathrel{=}\Varid{error}\;\text{\tt \char34 O~has~no~coordinates\char34}{}\<[E]%
\\
\>[3]{}\Varid{xco}\;(\Conid{P}\;{}\<[11]%
\>[11]{}\Varid{x}\;\anonymous )\mathrel{=}\Varid{x}{}\<[E]%
\\[\blanklineskip]%
\>[3]{}\Varid{yco}\mathbin{::}\Conid{Point}\to \Conid{Natural}{}\<[E]%
\\
\>[3]{}\Varid{yco}\;\Conid{O}\mathrel{=}\Varid{error}\;\text{\tt \char34 O~has~no~coordinates\char34}{}\<[E]%
\\
\>[3]{}\Varid{yco}\;(\Conid{P}\;\anonymous \;\Varid{y})\mathrel{=}\Varid{y}{}\<[E]%
\ColumnHook
\end{pboxed}
\)\par\noindent\endgroup\resethooks
\end{minipage}

To be sure that the points we create are modulo $p$,
we define a convenient creator function:

\begin{minipage}{\textwidth}
\begingroup\par\noindent\advance\leftskip\mathindent\(
\begin{pboxed}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{5}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[3]{}\Varid{point}\mathbin{::}\Conid{Curve}\to (\Conid{Natural},\Conid{Natural})\to \Conid{Point}{}\<[E]%
\\
\>[3]{}\Varid{point}\;\Varid{c}\;(\Varid{x},\Varid{y})\mathrel{=}\Conid{P}\;(\Varid{x}\mathbin{\Varid{`mod`}}\Varid{p})\;(\Varid{y}\mathbin{\Varid{`mod`}}\Varid{p}){}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}\mathbf{where}\;\Varid{p}\mathrel{=}\Varid{curM}\;\Varid{c}{}\<[E]%
\ColumnHook
\end{pboxed}
\)\par\noindent\endgroup\resethooks
\end{minipage}

Note that we use our \ensuremath{\Varid{mod}} function defined in
section on modular arithmetic in the Prime chapter.

\ignore{
\begingroup\par\noindent\advance\leftskip\mathindent\(
\begin{pboxed}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{12}{@{}>{\hspre}l<{\hspost}@{}}%
\column{25}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[3]{}\Varid{mod}\mathbin{::}\Conid{Natural}\to \Conid{Natural}\to \Conid{Natural}{}\<[E]%
\\
\>[3]{}\Varid{mod}\;\Varid{x}\;\Varid{n}{}\<[12]%
\>[12]{}\mid \Varid{x}\mathbin{<}\mathrm{0}{}\<[25]%
\>[25]{}\mathrel{=}\Varid{n}\mathbin{-}((\mathbin{-}\Varid{x})\mathbin{\Varid{`rem`}}\Varid{n}){}\<[E]%
\\
\>[12]{}\mid \Varid{otherwise}{}\<[25]%
\>[25]{}\mathrel{=}\Varid{x}\mathbin{\Varid{`rem`}}\Varid{n}{}\<[E]%
\ColumnHook
\end{pboxed}
\)\par\noindent\endgroup\resethooks
}

Now we would like to have a function that
gives us the $y$-coordinate of the point 
with a given $x$-coordinate. In the continuous
universe that would be quite easy.
It is a bit complicated in modular arithmetic.
We start with a function that gives us $y^2$:

\begin{minipage}{\textwidth}
\begingroup\par\noindent\advance\leftskip\mathindent\(
\begin{pboxed}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{5}{@{}>{\hspre}l<{\hspost}@{}}%
\column{12}{@{}>{\hspre}l<{\hspost}@{}}%
\column{15}{@{}>{\hspre}c<{\hspost}@{}}%
\column{15E}{@{}l@{}}%
\column{18}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[3]{}\Varid{curveY'2}\mathbin{::}\Conid{Curve}\to \Conid{Natural}\to \Conid{Natural}{}\<[E]%
\\
\>[3]{}\Varid{curveY'2}\;\Varid{c}\;\Varid{x}\mathrel{=}(\Varid{x}\mathbin{\uparrow}\mathrm{3}\mathbin{+}\Varid{a}\mathbin{*}\Varid{x}\mathbin{+}\Varid{b})\mathbin{\Varid{`mod`}}\Varid{p}{}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}\mathbf{where}\;{}\<[12]%
\>[12]{}\Varid{a}{}\<[15]%
\>[15]{}\mathrel{=}{}\<[15E]%
\>[18]{}\Varid{curA}\;\Varid{c}{}\<[E]%
\\
\>[12]{}\Varid{b}{}\<[15]%
\>[15]{}\mathrel{=}{}\<[15E]%
\>[18]{}\Varid{curB}\;\Varid{c}{}\<[E]%
\\
\>[12]{}\Varid{p}{}\<[15]%
\>[15]{}\mathrel{=}{}\<[15E]%
\>[18]{}\Varid{curM}\;\Varid{c}{}\<[E]%
\ColumnHook
\end{pboxed}
\)\par\noindent\endgroup\resethooks
\end{minipage}

That is neat and simple.
We just plug the given $x$-value into
the right-hand side of the curve equation
and get $y^2$ back. But, now, how to compute $y$?
In the continuous universe, we would just call
$\sqrt{y^2}$. But we are in modular arithmetic
and $y^2$ is not necessarily a perfect square,
but a quadratic residue, which may or may not
be a perfect square. Here are as an example
the residues of prime 17:

\[
0, 1, 2, 4, 8, 9, 13, 15, 16.
\]

Those are nine numbers, which was to be expected,
since, for any prime modulus $p$, there are 
$\frac{p+1}{2}$ residues and $\frac{p-1}{2}$ nonresidues.
Of these nine numbers, only five, namely
0, 1, 4, 9 and 16, are perfect squares.
For those it is quite easy to compute the root.
It is just the regular square root.
For the others, however, it is quite hard.
The problem is closely related to the 
Discrete Logarithm Problem (\acronym{dlp}),
which is hard enough to provide the setting
for most public key cryptographic schemes
around today. Anyway, we have to live with it
for the moment and implement a searching algorithm
that is fine for small modulus, but infeasible in
practice:

\begin{minipage}{\textwidth}
\begingroup\par\noindent\advance\leftskip\mathindent\(
\begin{pboxed}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{5}{@{}>{\hspre}l<{\hspost}@{}}%
\column{12}{@{}>{\hspre}l<{\hspost}@{}}%
\column{18}{@{}>{\hspre}l<{\hspost}@{}}%
\column{39}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[3]{}\Varid{findRoot}\mathbin{::}\Conid{Natural}\to \Conid{Natural}\to \Conid{Natural}{}\<[E]%
\\
\>[3]{}\Varid{findRoot}\;\Varid{p}\;\Varid{q}\mathrel{=}\Varid{go}\;\mathrm{0}{}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}\mathbf{where}\;{}\<[12]%
\>[12]{}\Varid{go}\;\Varid{x}{}\<[18]%
\>[18]{}\mid \Varid{x}\mathbin{>}\Varid{p}{}\<[39]%
\>[39]{}\mathrel{=}\Varid{error}\;\text{\tt \char34 not~found!\char34}{}\<[E]%
\\
\>[18]{}\mid (\Varid{x}\mathbin{\uparrow}\mathrm{2})\mathbin{\Varid{`mod`}}\Varid{p}\equiv \Varid{q}\mathrel{=}\Varid{x}{}\<[E]%
\\
\>[18]{}\mid \Varid{otherwise}{}\<[39]%
\>[39]{}\mathrel{=}\Varid{go}\;(\Varid{x}\mathbin{+}\mathrm{1}){}\<[E]%
\ColumnHook
\end{pboxed}
\)\par\noindent\endgroup\resethooks
\end{minipage}

Basically, we just go through all numbers 
from 0 to $p-1$, until we find one that squared
yields $q$, the residue in question.
If we do not find such a number, 
we terminate with an error.
If we map \ensuremath{\Varid{findRoot}} on the residues of 17,
\ensuremath{\Varid{map}\;(\Varid{findRoot}\;\mathrm{17})\;(\Varid{residues}\;\mathrm{17})}, we see:

\[
0, 1, 6, 2, 5, 3, 8, 7, 4.
\]

Some numbers are not surprising at all.
0 is of course the root of 0 and so is
1 of 1, 2 of 4, 3 of 9 and 4 of 16.
But who had thought that 6 is the root
of 2, 8 that of 13 or 7 that of 15?

With the help of this root finder,
we can now implement a function 
that gives us $y$ for $x$:

\begin{minipage}{\textwidth}
\begingroup\par\noindent\advance\leftskip\mathindent\(
\begin{pboxed}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{5}{@{}>{\hspre}l<{\hspost}@{}}%
\column{17}{@{}>{\hspre}l<{\hspost}@{}}%
\column{35}{@{}>{\hspre}l<{\hspost}@{}}%
\column{41}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[3]{}\Varid{curveY}\mathbin{::}\Conid{Curve}\to \Conid{Natural}\to \Conid{Maybe}\;\Conid{Natural}{}\<[E]%
\\
\>[3]{}\Varid{curveY}\;\Varid{c}\;\Varid{x}\mathrel{=}{}\<[17]%
\>[17]{}\mathbf{let}\;\Varid{r}\mathrel{=}\Varid{curveY'2}\;\Varid{c}\;\Varid{x}{}\<[E]%
\\
\>[17]{}\mathbf{in}\;\mathbf{if}\;\Varid{isSqrM}\;\Varid{r}\;\Varid{p}\;{}\<[35]%
\>[35]{}\mathbf{then}\;{}\<[41]%
\>[41]{}\Conid{Just}\;(\Varid{findRoot}\;\Varid{p}\;\Varid{r}){}\<[E]%
\\
\>[35]{}\mathbf{else}\;{}\<[41]%
\>[41]{}\Conid{Nothing}{}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}\mathbf{where}\;\Varid{p}\mathrel{=}\Varid{curM}\;\Varid{c}{}\<[E]%
\ColumnHook
\end{pboxed}
\)\par\noindent\endgroup\resethooks
\end{minipage}

We have inserted a safety belt in this function.
Before we go into \ensuremath{\Varid{findRoot}}, which may cause an error
when there is no root for the number in question,
we check if it is a residue at all.
If it is, we are confident to find a root and just
return the result of \ensuremath{\Varid{findRoot}}. Otherwise,
we return \ensuremath{\Conid{Nothing}}, meaning that the curve is
not defined for this specific $x$.
Here is the test for $r$ being a residue
using the Legendre symbol:

\begin{minipage}{\textwidth}
\begingroup\par\noindent\advance\leftskip\mathindent\(
\begin{pboxed}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{15}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[3]{}\Varid{isSqrM}\mathbin{::}\Conid{Natural}\to \Conid{Natural}\to \Conid{Bool}{}\<[E]%
\\
\>[3]{}\Varid{isSqrM}\;\mathrm{0}\;\anonymous {}\<[15]%
\>[15]{}\mathrel{=}\Conid{True}{}\<[E]%
\\
\>[3]{}\Varid{isSqrM}\;\Varid{n}\;\Varid{p}{}\<[15]%
\>[15]{}\mathrel{=}\Varid{legendre}\;\Varid{n}\;\Varid{p}\equiv \mathrm{1}{}\<[E]%
\ColumnHook
\end{pboxed}
\)\par\noindent\endgroup\resethooks
\end{minipage}

Based on these functions,
we can define other useful tools.
A function that verifies wether a given point
is on the curve:

\begin{minipage}{\textwidth}
\begingroup\par\noindent\advance\leftskip\mathindent\(
\begin{pboxed}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{5}{@{}>{\hspre}l<{\hspost}@{}}%
\column{22}{@{}>{\hspre}c<{\hspost}@{}}%
\column{22E}{@{}l@{}}%
\column{25}{@{}>{\hspre}l<{\hspost}@{}}%
\column{31}{@{}>{\hspre}l<{\hspost}@{}}%
\column{40}{@{}>{\hspre}l<{\hspost}@{}}%
\column{44}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[3]{}\Varid{oncurve}\mathbin{::}\Conid{Curve}\to \Conid{Point}\to \Conid{Bool}{}\<[E]%
\\
\>[3]{}\Varid{oncurve}\;\anonymous \;\Conid{O}{}\<[22]%
\>[22]{}\mathrel{=}{}\<[22E]%
\>[25]{}\Conid{True}{}\<[E]%
\\
\>[3]{}\Varid{oncurve}\;\Varid{c}\;(\Conid{P}\;\Varid{x}\;\Varid{y}){}\<[22]%
\>[22]{}\mathrel{=}{}\<[22E]%
\>[25]{}\mathbf{case}\;{}\<[31]%
\>[31]{}\Varid{curveY}\;\Varid{c}\;\Varid{x}\;\mathbf{of}{}\<[E]%
\\
\>[31]{}\Conid{Nothing}{}\<[40]%
\>[40]{}\to \Conid{False}{}\<[E]%
\\
\>[31]{}\Conid{Just}\;\Varid{z}{}\<[40]%
\>[40]{}\to {}\<[44]%
\>[44]{}\Varid{y}\equiv \Varid{z}\mathrel{\vee}\Varid{y}\equiv \Varid{p}\mathbin{-}\Varid{z}{}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}\mathbf{where}\;\Varid{p}\mathrel{=}\Varid{curM}\;\Varid{c}{}\<[E]%
\ColumnHook
\end{pboxed}
\)\par\noindent\endgroup\resethooks
\end{minipage}

The function receives a curve and a point.
It determines the $y$-coordinate for the $x$-coordinate
of the point. If no $y$-coordinate is found,
the point is certainly not on the curve.
Otherwise, if the $y$ we found is the same 
as the one of the point, then the point is on the curve. 
If the value we found is $-y$, 
that is to say, $p-y$, then the point is also on the curve,
because $p-y$ is the additive inverse of $y$ in the group
and, if the point $(x,-y)$ is on the curve, then 
$(x,y)$, the inverse of the point, is also in on the curve.
Note that, when we say ``a point is on the curve'', 
we effectively say ``the point is in the group''. 
But be careful: we are here referring to two different groups.
The group of integers modulo $p$ and the group of points
that ``are on the curve''.

The function \ensuremath{\Varid{oncurve}} is not very efficient,
since it needs the root to calculate the result of \ensuremath{\Varid{curveY}}.
A more efficient version is this one:

\begin{minipage}{\textwidth}
\begingroup\par\noindent\advance\leftskip\mathindent\(
\begin{pboxed}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{5}{@{}>{\hspre}l<{\hspost}@{}}%
\column{24}{@{}>{\hspre}l<{\hspost}@{}}%
\column{27}{@{}>{\hspre}l<{\hspost}@{}}%
\column{32}{@{}>{\hspre}l<{\hspost}@{}}%
\column{41}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[3]{}\Varid{oncurve'2}\mathbin{::}\Conid{Curve}\to \Conid{Point}\to \Conid{Bool}{}\<[E]%
\\
\>[3]{}\Varid{oncurve'2}\;\anonymous \;\Conid{O}{}\<[24]%
\>[24]{}\mathrel{=}\Conid{True}{}\<[E]%
\\
\>[3]{}\Varid{oncurve'2}\;\Varid{c}\;(\Conid{P}\;\Varid{x}\;\Varid{y}){}\<[24]%
\>[24]{}\mathrel{=}{}\<[27]%
\>[27]{}\mathbf{let}\;{}\<[32]%
\>[32]{}\Varid{z}\mathrel{=}\Varid{curveY'2}\;\Varid{c}\;\Varid{x}{}\<[E]%
\\
\>[27]{}\mathbf{in}\;{}\<[32]%
\>[32]{}(\Varid{y}\mathbin{\uparrow}\mathrm{2}){}\<[41]%
\>[41]{}\mathbin{\Varid{`mod`}}\Varid{p}\equiv \Varid{z}\mathrel{\vee}{}\<[E]%
\\
\>[32]{}(\Varid{p}\mathbin{-}\Varid{y})\mathbin{\uparrow}\mathrm{2}{}\<[41]%
\>[41]{}\mathbin{\Varid{`mod`}}\Varid{p}\equiv \Varid{z}{}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}\mathbf{where}\;\Varid{p}\mathrel{=}\Varid{curM}\;\Varid{c}{}\<[E]%
\ColumnHook
\end{pboxed}
\)\par\noindent\endgroup\resethooks
\end{minipage}

As we are already dealing with inverses,
here are two functions, one finding
the inverse of a point and the other
testing if a point is the inverse of the other: 

\begin{minipage}{\textwidth}
\begingroup\par\noindent\advance\leftskip\mathindent\(
\begin{pboxed}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{20}{@{}>{\hspre}l<{\hspost}@{}}%
\column{23}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[3]{}\Varid{pinverse}\mathbin{::}\Conid{Curve}\to \Conid{Point}\to \Conid{Point}{}\<[E]%
\\
\>[3]{}\Varid{pinverse}\;\anonymous \;\Conid{O}{}\<[23]%
\>[23]{}\mathrel{=}\Conid{O}{}\<[E]%
\\
\>[3]{}\Varid{pinverse}\;\Varid{c}\;(\Conid{P}\;\Varid{x}\;\Varid{y}){}\<[23]%
\>[23]{}\mathrel{=}\Varid{point}\;\Varid{c}\;(\Varid{x},\mathbin{-}\Varid{y}){}\<[E]%
\\[\blanklineskip]%
\>[3]{}\Varid{isInverse}\mathbin{::}\Conid{Curve}\to \Conid{Point}\to \Conid{Point}\to \Conid{Bool}{}\<[E]%
\\
\>[3]{}\Varid{isInverse}\;\anonymous \;\Conid{O}\;\Conid{O}{}\<[20]%
\>[20]{}\mathrel{=}\Conid{True}{}\<[E]%
\\
\>[3]{}\Varid{isInverse}\;\Varid{c}\;\Varid{p}\;\Varid{q}{}\<[20]%
\>[20]{}\mathrel{=}\Varid{q}\equiv \Varid{pinverse}\;\Varid{c}\;\Varid{p}{}\<[E]%
\ColumnHook
\end{pboxed}
\)\par\noindent\endgroup\resethooks
\end{minipage}

Another useful tool would be one to find us a point
on the curve. There are two ways to do it:
deterministic and random.
We start with the deterministic function that would
basically go through all number from 0 to $p-1$ and stop,
whenever there is a $y$ for this $x$, such that $(x,y)$
is on the curve:

\begin{minipage}{\textwidth}
\begingroup\par\noindent\advance\leftskip\mathindent\(
\begin{pboxed}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{5}{@{}>{\hspre}l<{\hspost}@{}}%
\column{12}{@{}>{\hspre}l<{\hspost}@{}}%
\column{16}{@{}>{\hspre}c<{\hspost}@{}}%
\column{16E}{@{}l@{}}%
\column{17}{@{}>{\hspre}c<{\hspost}@{}}%
\column{17E}{@{}l@{}}%
\column{19}{@{}>{\hspre}l<{\hspost}@{}}%
\column{20}{@{}>{\hspre}l<{\hspost}@{}}%
\column{24}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[3]{}\Varid{findPoint}\mathbin{::}\Conid{Curve}\to \Conid{Point}{}\<[E]%
\\
\>[3]{}\Varid{findPoint}\;\Varid{c}{}\<[16]%
\>[16]{}\mathrel{=}{}\<[16E]%
\>[19]{}\mathbf{let}\;{}\<[24]%
\>[24]{}(\Varid{x},\Varid{y'})\mathrel{=}\Varid{hf}\;[\mskip1.5mu (\Varid{x},\Varid{curveY'2}\;\Varid{c}\;\Varid{x})\mid \Varid{x}\leftarrow [\mskip1.5mu \mathrm{1}\mathinner{\ldotp\ldotp}\mskip1.5mu]\mskip1.5mu]{}\<[E]%
\\
\>[19]{}\mathbf{in}\;{}\<[24]%
\>[24]{}\Varid{point}\;\Varid{c}\;(\Varid{x},\Varid{findRoot}\;\Varid{p}\;\Varid{y'}){}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}\mathbf{where}\;{}\<[12]%
\>[12]{}\Varid{hf}{}\<[17]%
\>[17]{}\mathrel{=}{}\<[17E]%
\>[20]{}\Varid{head}\mathbin{\circ}\Varid{filter}\;(\Varid{ism}\;\Varid{p}\mathbin{\circ}\Varid{snd}){}\<[E]%
\\
\>[12]{}\Varid{p}{}\<[17]%
\>[17]{}\mathrel{=}{}\<[17E]%
\>[20]{}\Varid{curM}\;\Varid{c}{}\<[E]%
\\
\>[12]{}\Varid{ism}{}\<[17]%
\>[17]{}\mathrel{=}{}\<[17E]%
\>[20]{}\Varid{flip}\;\Varid{isSqrM}{}\<[E]%
\ColumnHook
\end{pboxed}
\)\par\noindent\endgroup\resethooks
\end{minipage}

The function generates tuples of the form
$(x, y^2)$ and filters those where $y^2$ is
indeed a residue of $p$. The first of the resulting list
is returned and laziness saves us from going
through literally all possible $x$.
This is a very useful tool to get started
with a curve, but it is a bit boring,
because it would always yield the same point.
Randomness would make that more exciting
giving us different points. Here is a 
function that yields a random point on a
given curve:

\begin{minipage}{\textwidth}
\begingroup\par\noindent\advance\leftskip\mathindent\(
\begin{pboxed}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{5}{@{}>{\hspre}l<{\hspost}@{}}%
\column{21}{@{}>{\hspre}l<{\hspost}@{}}%
\column{27}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[3]{}\Varid{randomPoint}\mathbin{::}\Conid{Curve}\to \Conid{IO}\;\Conid{Point}{}\<[E]%
\\
\>[3]{}\Varid{randomPoint}\;\Varid{c}\mathrel{=}\mathbf{do}{}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}\Varid{x}\leftarrow \Varid{randomRIO}\;(\mathrm{1},\Varid{p}\mathbin{-}\mathrm{1}){}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}\mathbf{let}\;\Varid{y'}\mathrel{=}\Varid{curveY'2}\;\Varid{c}\;\Varid{x}{}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}\mathbf{if}\;\Varid{isSqrM}\;\Varid{y'}\;\Varid{p}\;{}\<[21]%
\>[21]{}\mathbf{then}\;{}\<[27]%
\>[27]{}\Varid{return}\;(\Varid{point}\;\Varid{c}\;(\Varid{x},\Varid{findRoot}\;\Varid{p}\;\Varid{y'})){}\<[E]%
\\
\>[21]{}\mathbf{else}\;{}\<[27]%
\>[27]{}\Varid{randomPoint}\;\Varid{c}{}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}\mathbf{where}\;\Varid{p}\mathrel{=}\Varid{curM}\;\Varid{c}{}\<[E]%
\ColumnHook
\end{pboxed}
\)\par\noindent\endgroup\resethooks
\end{minipage}

The code is straight forward.
First we generate a random number $x$ 
in the range $1\dots p-1$.
Then we determine $y^2$ and, if this is a residue,
we return the point consisting of $x$ and $y$.
Otherwise, if it is not a residue, we start all over again.

Let us take a break here and look at some points
in a real curve. We start by defining a curve for
experiments:

\begin{minipage}{\textwidth}
\begingroup\par\noindent\advance\leftskip\mathindent\(
\begin{pboxed}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[3]{}\Varid{c1}\mathbin{::}\Conid{Curve}{}\<[E]%
\\
\>[3]{}\Varid{c1}\mathrel{=}\Conid{Curve}\;\mathrm{2}\;\mathrm{2}\;\mathrm{17}{}\<[E]%
\ColumnHook
\end{pboxed}
\)\par\noindent\endgroup\resethooks
\end{minipage}

This corresponds to the curve 

\[
y^2 \equiv x^3 + 2x + 2 \pmod{17}.
\]

We call \ensuremath{\Varid{mapM}\;(\mathbin{\char92 \char95 }\to \Varid{randomPoint}\;\Varid{c1})\;[\mskip1.5mu \mathrm{1}\mathinner{\ldotp\ldotp}\mathrm{5}\mskip1.5mu]},
generating five random points.
We may see the points

\[
(10,6), (5,1), (6,3), (3,1), (13,7)
\]

(or any other selection of points. It is a \textbf{random} list!)
As expected, we see points with integer
coordinates in the range $0\dots 16$.
Let us look where those points are located in 
the Cartesian plane.

\begin{center}
\begin{tikzpicture}
   \draw [->] (0,0) -- (5,0);
   \draw [->] (0,0) -- (0,4);

   \draw [teal,fill=teal] (2.5,1.5) circle (1.5pt);
   \draw [teal,fill=teal] (1.25,0.25) circle (1.5pt);
   \draw [teal,fill=teal] (1.5,0.75) circle (1.5pt);
   \draw [teal,fill=teal] (1.5,0.25) circle (1.5pt);
   \draw [teal,fill=teal] (3.25,1.75) circle (1.5pt);

\end{tikzpicture}
\end{center}

As already said: that does not look like 
an elliptic curve at all. It does not look completely
random either.
To have the complete picture, however, we need
all points on that curve. 
How can we get them? Right! With a generator!
Where do we get a generator? 
One way is trial and error.
But for that we need the group operation.
So let us get on with it. Here is addition:

\begin{minipage}{\textwidth}
\begingroup\par\noindent\advance\leftskip\mathindent\(
\begin{pboxed}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{7}{@{}>{\hspre}l<{\hspost}@{}}%
\column{14}{@{}>{\hspre}l<{\hspost}@{}}%
\column{16}{@{}>{\hspre}l<{\hspost}@{}}%
\column{17}{@{}>{\hspre}c<{\hspost}@{}}%
\column{17E}{@{}l@{}}%
\column{20}{@{}>{\hspre}l<{\hspost}@{}}%
\column{25}{@{}>{\hspre}l<{\hspost}@{}}%
\column{31}{@{}>{\hspre}l<{\hspost}@{}}%
\column{34}{@{}>{\hspre}c<{\hspost}@{}}%
\column{34E}{@{}l@{}}%
\column{37}{@{}>{\hspre}l<{\hspost}@{}}%
\column{42}{@{}>{\hspre}l<{\hspost}@{}}%
\column{44}{@{}>{\hspre}l<{\hspost}@{}}%
\column{50}{@{}>{\hspre}l<{\hspost}@{}}%
\column{55}{@{}>{\hspre}l<{\hspost}@{}}%
\column{65}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[3]{}\Varid{add}\mathbin{::}\Conid{Curve}\to \Conid{Point}\to \Conid{Point}\to \Conid{Point}{}\<[E]%
\\
\>[3]{}\Varid{add}\;\anonymous \;\anonymous \;\Varid{p}\;\Conid{O}{}\<[16]%
\>[16]{}\mathrel{=}\Varid{p}{}\<[E]%
\\
\>[3]{}\Varid{add}\;\anonymous \;\anonymous \;\Conid{O}\;\Varid{p}{}\<[16]%
\>[16]{}\mathrel{=}\Varid{p}{}\<[E]%
\\
\>[3]{}\Varid{add}\;\Varid{c}\;\Varid{p}\mathord{@}(\Conid{P}\;\Varid{x1}\;\Varid{y1})\;\Varid{q}\mathord{@}(\Conid{P}\;\Varid{x2}\;\Varid{y2}){}\<[34]%
\>[34]{}\mid {}\<[34E]%
\>[37]{}\Varid{isInverse}\;\Varid{c}\;\Varid{p}\;\Varid{q}{}\<[55]%
\>[55]{}\mathrel{=}\Conid{O}{}\<[E]%
\\
\>[34]{}\mid {}\<[34E]%
\>[37]{}\Varid{otherwise}{}\<[55]%
\>[55]{}\mathrel{=}{}\<[E]%
\\
\>[37]{}\mathbf{let}\;{}\<[42]%
\>[42]{}\Varid{xr}\mathrel{=}(\Varid{l}\mathbin{\uparrow}\mathrm{2}\mathbin{-}\Varid{x1}\mathbin{-}\Varid{x2}){}\<[65]%
\>[65]{}\mathbin{\Varid{`mod`}}\Varid{m}{}\<[E]%
\\
\>[42]{}\Varid{yr}\mathrel{=}(\Varid{l}\mathbin{*}(\Varid{xr}\mathbin{-}\Varid{x1})\mathbin{+}\Varid{y1}){}\<[65]%
\>[65]{}\mathbin{\Varid{`mod`}}\Varid{m}{}\<[E]%
\\
\>[37]{}\mathbf{in}\;\Varid{point}\;\Varid{c}\;(\Varid{xr},\mathbin{-}\Varid{yr}){}\<[E]%
\\
\>[3]{}\hsindent{4}{}\<[7]%
\>[7]{}\mathbf{where}\;{}\<[14]%
\>[14]{}\Varid{a}{}\<[31]%
\>[31]{}\mathrel{=}\Varid{curA}\;\Varid{c}{}\<[E]%
\\
\>[14]{}\Varid{m}{}\<[31]%
\>[31]{}\mathrel{=}\Varid{curM}\;\Varid{c}{}\<[E]%
\\
\>[14]{}\Varid{l}{}\<[17]%
\>[17]{}\mid {}\<[17E]%
\>[20]{}\Varid{x1}\equiv \Varid{x2}{}\<[31]%
\>[31]{}\mathrel{=}{}\<[E]%
\\
\>[20]{}\mathbf{let}\;{}\<[25]%
\>[25]{}\Varid{t1}{}\<[31]%
\>[31]{}\mathrel{=}(\mathrm{3}\mathbin{*}\Varid{x1}\mathbin{\uparrow}\mathrm{2}\mathbin{+}\Varid{a}){}\<[50]%
\>[50]{}\mathbin{\Varid{`mod`}}\Varid{m}{}\<[E]%
\\
\>[25]{}\Varid{t2}{}\<[31]%
\>[31]{}\mathrel{=}\Varid{inverse}\;((\mathrm{2}\mathbin{*}\Varid{y1}){}\<[50]%
\>[50]{}\mathbin{\Varid{`mod`}}\Varid{m})\;\Varid{m}{}\<[E]%
\\
\>[20]{}\mathbf{in}\;{}\<[25]%
\>[25]{}(\Varid{t1}\mathbin{*}\Varid{t2})\mathbin{\Varid{`mod`}}\Varid{m}{}\<[E]%
\\
\>[17]{}\mid {}\<[17E]%
\>[20]{}\Varid{otherwise}{}\<[31]%
\>[31]{}\mathrel{=}{}\<[E]%
\\
\>[20]{}\mathbf{let}\;{}\<[25]%
\>[25]{}\Varid{t1}{}\<[31]%
\>[31]{}\mathrel{=}{}\<[44]%
\>[44]{}(\Varid{y2}\mathbin{-}\Varid{y1})\mathbin{\Varid{`mod`}}\Varid{m}{}\<[E]%
\\
\>[25]{}\Varid{t2}{}\<[31]%
\>[31]{}\mathrel{=}\Varid{inverse}\;({}\<[44]%
\>[44]{}(\Varid{x2}\mathbin{-}\Varid{x1})\mathbin{\Varid{`mod`}}\Varid{m})\;\Varid{m}{}\<[E]%
\\
\>[20]{}\mathbf{in}\;{}\<[25]%
\>[25]{}(\Varid{t1}\mathbin{*}\Varid{t2})\mathbin{\Varid{`mod`}}\Varid{m}{}\<[E]%
\ColumnHook
\end{pboxed}
\)\par\noindent\endgroup\resethooks
\end{minipage}

We start with the base cases where 
one of the points is $\mathcal{O}$,
the identity of the group of the curve.
The result of addition in this case is just
the other point. Then we handle two points
none of which is the identity.
If one is the inverse of the other,
then the result is just $\mathcal{O}$.
All these cases, as already mentioned
in the previous section, must be explicitly
handled in our implementation. There is no
direct way that would produce the result.
After all, this is a highly ``engineered'' group.

Now, we are finally in the ``regular'' case,
where none of the points is the identity and
the points are not the inverses of each other.
In this case -- we just apply the formula
we have learnt before. However, it looks a bit different.
This is because we are now in the discrete
universe of modular arithmetic. 
The main difference is that, 
instead of dividing coordinates, we multiply them
by the modular inverse of the denominator.
We are here dealing with the group of integers
modulo the prime we use for the curve.

It should be mentioned that to compute the slope
of the line $l$, we distinguish the cases 
$p = q$ (point doubling) and $p \neq q$ by
just comparing the $x$-coordinates ignoring
the $y$-coordinates. We can do this, because
we already have checked one point being
the inverse of the other. Since the inverse
of a point $(x,y)$ is its reflection across
the $x$-axis $(x,-y)$ and there, for sure,
is no other point with that $x$-coordinate,
it would be redundant to check the $y$-coordinate
once again.

What do points look like, when we add them up?
Let us take two points from the list above.
What about the first two, $(10,6)$ 
and $(5,1)$? We add them
calling\\
\ensuremath{\Varid{add}\;\Varid{c1}\;(\Conid{P}\;\mathrm{10}\;\mathrm{6})\;(\Conid{P}\;\mathrm{5}\;\mathrm{1})} and get

\[
(3,1).
\] 

There is really nothing that would suggest
any similarity to ordinary arithmetic addition.

How can we use addition to generate the
whole group? Since we are dealing with an
additive group (according to this strange
definition of addition), we can pick a primitive
element, a generator, and add it successivley
to itself. But what is a primitive element
of the group of our curve $c1$? Well,
I happen to know that the order of that group
is 19. Since 19 is a prime number and
since we are talking about groups, Lagrange's theorem
applies, \ie\ the order of subgroups must divide
the order of the main group. Therefore,
all members of the group are either member
of a trivial subgroup (which contains only one element,
namely the identity)
or generators of the main group. Since the sole element
in the trivial group must be the identity $\mathcal{O}$,
all other members of the group must be generators.
We, hence, can pick any point and generate the whole
group from it. Here is a generator function:

\begin{minipage}{\textwidth}
\begingroup\par\noindent\advance\leftskip\mathindent\(
\begin{pboxed}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{5}{@{}>{\hspre}l<{\hspost}@{}}%
\column{12}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[3]{}\Varid{gen}\mathbin{::}\Conid{Curve}\to \Conid{Point}\to [\mskip1.5mu \Conid{Point}\mskip1.5mu]{}\<[E]%
\\
\>[3]{}\Varid{gen}\;\Varid{c}\;\Varid{p}\mathrel{=}\Varid{go}\;\Varid{p}{}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}\mathbf{where}\;{}\<[12]%
\>[12]{}\Varid{go}\;\Conid{O}\mathrel{=}[\mskip1.5mu \Conid{O}\mskip1.5mu]{}\<[E]%
\\
\>[12]{}\Varid{go}\;\Varid{r}\mathrel{=}\Varid{r}\mathbin{:}\Varid{go}\;(\Varid{add}\;\Varid{c}\;\Varid{r}\;\Varid{p}){}\<[E]%
\ColumnHook
\end{pboxed}
\)\par\noindent\endgroup\resethooks
\end{minipage}

We call it like \ensuremath{\Varid{gen}\;\Varid{c1}\;(\Conid{P}\;\mathrm{10}\;\mathrm{6})} and get

\[
(10,6),(16,13),(7,6),(0,11),(3,16),(5,16),(6,3),
\]\[
(9,16),(13,7),(13,10),(9,1),(6,14),(5,1),(3,1),\\
\]\[
(0,6),(7,11),(16,4),(10,11),O,
\]

which are 19 points and, hence, the entire group
of the curve $c1$.

Note that the final point is the identity.
This is exactly the same behaviour as we saw
for multiplicative groups modulo a prime.
For instance, 3 is a generator of the group
modulo 7. We saw that 
$3^1 \equiv 3$,
$3^2 \equiv 2$,
$3^3 \equiv 6$,
$3^4 \equiv 4$,
$3^5 \equiv 5$ and
$3^6 \equiv 1$ all $\pmod{7}$.
 
The last but one point in the list is the inverse
of the point we started with. In the integer case,
there was nothing obvious that pointed to the fact
that 5 is the inverse of 3 modulo 7. With the points
above, however, it is immediately clear, since,
as you can see, the penultimate point is $(10,11)$.
It has the same $x$-coordinate as $(10,6)$ and the
$y$-coordinate is $-y$ of the original point, because
$17-6 = 11$. 11, hence, is $-6$ modulo 17.

Do we get a clearer picture when we put all 
these points on the Cartesian plane? Not really:

\begin{center}
\begin{tikzpicture}
   \draw [->] (0,0) -- (6,0);
   \draw [->] (0,0) -- (0,6);

   \draw [teal,fill=teal] (2.5 ,1.5 ) circle (1.5pt);
   \draw [teal,fill=teal] (4   ,3.25) circle (1.5pt);
   \draw [teal,fill=teal] (3.5 ,3   ) circle (1.5pt);
   \draw [teal,fill=teal] (0   ,2.75) circle (1.5pt);
   \draw [teal,fill=teal] (0.75,4   ) circle (1.5pt);
   \draw [teal,fill=teal] (1.25,4   ) circle (1.5pt);
   \draw [teal,fill=teal] (1.5 ,0.75) circle (1.5pt);

   \draw [teal,fill=teal] (2.25,4   ) circle (1.5pt);
   \draw [teal,fill=teal] (3.25,1.75) circle (1.5pt);
   \draw [teal,fill=teal] (3.25,2.5 ) circle (1.5pt);
   \draw [teal,fill=teal] (2.25,0.25) circle (1.5pt);
   \draw [teal,fill=teal] (1.5 ,3.5 ) circle (1.5pt);
   \draw [teal,fill=teal] (1.25,0.75) circle (1.5pt);
   \draw [teal,fill=teal] (0.75,0.75) circle (1.5pt);

   \draw [teal,fill=teal] (0   ,1.5 ) circle (1.5pt);
   \draw [teal,fill=teal] (1.75,3.75) circle (1.5pt);
   \draw [teal,fill=teal] (4   ,1   ) circle (1.5pt);
   \draw [teal,fill=teal] (2.5 ,3.75) circle (1.5pt);

\end{tikzpicture}
\end{center}

So, let us forget about geometry for a while.
We are dealing with modular arithmetic related
to a construction that we happen to call a curve.
There is no more secret geometry behind it.
\section{The EC Discrete Logarithm Problem} 
\ignore{
\begingroup\par\noindent\advance\leftskip\mathindent\(
\begin{pboxed}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\mathbf{module}\;\Conid{ECDLP}{}\<[E]%
\\
\>[B]{}\mathbf{where}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\mathbf{import}\;\Conid{ECModulo}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\mathbf{import}\;\Conid{Prelude}\;\Varid{hiding}\;(\Varid{mod}){}\<[E]%
\\[\blanklineskip]%
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\mathbf{import}\;\Conid{Prime}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\mathbf{import}\;\Conid{Modular}\;\Varid{hiding}\;(\Varid{add},\Varid{mul},\Varid{mDiv}){}\<[E]%
\ColumnHook
\end{pboxed}
\)\par\noindent\endgroup\resethooks
}

To summarise the results from the previous sections,
we can describe EC Crypto as a system with three layers.
The first layer consists in modular integer arithmetic
and is used to do the math underlying point addition.
Point addition itself belongs to the second layer,
the additive group of points on the curve,
which results from \emph{using} point addition.
Since all arithmetic modulo a prime is done within
point addition, when we look
at point addition itself, we do not ``see'' 
modular arithmetic anymore. We do not add points
modulo something, we just add them using the addition
formula.

The third layer consists of the cryptosystems built
on top of the group of points. To actually build
cryptosystems on top of elliptic curves,
we need a secret that we can use as private key
and an open parameter acting as public key.
Perhaps the following schematic sketch helps:

\begin{center}
\begin{tikzpicture}
\draw (0,0) rectangle (6,1.5);
\node [font=\small,align=center] (g1) at (3,0.75) 
      {$a^{\lambda(n)} \equiv 1 \pmod{n}$};
\draw (0,2) rectangle (6,3.5);
\node [font=\small,align=center] (g2) at (3,2.75) 
      {$nP = \mathcal{O}$};
\draw (0,4) rectangle (1.5,5.5);
\node [font=\small,align=center] (s1) at (0.75,4.75) 
      {\acronym{ecdh}};
\draw (1.5,4) rectangle (3,5.5);
\node [font=\small,align=center] (s1) at (2.25,4.75) 
      {\acronym{ecies}};
\draw (3,4) rectangle (4.5,5.5);
\node [font=\small,align=center] (s1) at (3.75,4.75) 
      {\acronym{ecdsa}};
\draw (4.5,4) rectangle (6,5.5);
\node [font=\small,align=center] (s1) at (5.25,4.75) 
      {\acronym{$\dots$}};
\draw [fill=white] (3, 1.75) ellipse (3cm and 0.5cm);
\node [font=\tiny ,align=center] (pa) at (3,1.75)
      {$(x_P,y_P) + (x_Q,y_Q) = (x_R,y_R)$}; 
\draw [fill=white] (3, 3.75) ellipse (3cm and 0.5cm);
\node [font=\tiny ,align=center] (sec) at (3,3.75)
      {$(private,public)$}; 
\end{tikzpicture}
\end{center}
\ignore{$}

Bottom up, we see first the arithmetic group
modulo some prime, indicated by Car\-michael's
theorem. On top of it, we built point addition,
which, in its turn, is the basis for the group
of points on the curve, indicated by the fact
that repeated addition (\ie\ multiplication)
of a point $P$ yields the identity of that group
$\mathcal{O}$. By means of this group,
we build a key pair $(public,private)$,
which then enables us to build concrete
cryptographic schemes, such as 
\acronym{ec} Diffie-Hellman (\acronym{ecdh}),
\acronym{ec} Integrated Encryption Scheme (\acronym{ecies}) and the
\acronym{ec} Digital Signature Algorithm (\acronym{ecdsa}),
which we will discuss in the next sections.
As indicated by the right-most box in that layer,
there are many more cryptographic schemes
for elliptic curves.
But we will not discuss all of them here. 

When we look back at classic cryptography, we see
that we typically used an invertible operation,
namely \term{exponentiation}. In some cases,
like in Diffie-Hellman, the private key was a
combination of public keys of the form
$a^{xy} = (a^x)^y = (a^y)^x$,
in others,
like \acronym{rsa}, public and private keys
were inverses of each other, such that 
$a^{ed} = a^1 = a$.
In either case, the security of the private key
was based on the hardness of the 
discrete logarithm problem (\acronym{dlp}).
The \acronym{dlp} aims to solve equations
of the form 

\[
a^x = b
\]

for $x$, \ie\ it asks for the number $x$,
to which we have to raise $a$ to get to $b$.
The classic crypto schemes are based on
a multiplicative group. The \acronym{dlp},
hence, asks for the number of repetitions
of successive multiplications of $a$ to get to $b$.
In \acronym{ec}, however, we have an additive group or,
at least, we use ``additive terminology'' describing
the group operation. When we ask for the number
of repetitions of that operation on $a$ to get $b$,
we would hence ask for multiplication, not
for exponentiation. There is some potential 
for confusion in this terminology switch
from multiplicative to additive groups.
The problem on which the security in \acronym{ec} relies
is unfortunately also called \acronym{dlp}, 
discrete logarithm problem.
It would be much more precise in this case to refer to the
\term{discrete quotient problem}, since we talk about
multiplication, not exponentiation.
However, the terminology is like that.
So, we stick to it and define the \acronym{dlp}
for \acronym{ec} crypto.

The information of \acronym{ec} crypto systems
that is publicly known 
consist of parameters describing the curve,
the coefficients, the modulus, a starting point $P$ and perhaps
some other details specifying the exact curve.
The public key is typically a point $Q$ and the 
secret is a natural number $n$, such that

\begin{equation}
nP = Q.
\end{equation}

The \acronym{dlp}, hence, consists in finding
a \emph{factor} $n$ that determines how often
we have to add $P$ to itself to get to $Q$.
This may sound weird, but, in fact, it is
a hard problem equivalent in computational complexity
to finding the discrete logarithm in classic
cryptography.

Consider the curve we already used above
with starting point $P=(5,1)$. If you consider the public
key to be $Q=(9,16)$, can you tell, without
looking at the whole group above, what $n$ must be,
such that $n\times (5,1) = (9,16)$?
The point is that no algorithm is known
that would do that in acceptable time
for large groups.
For this toy group, we obviously can try.
We would see that:

\[
(5,1) + (5,1) = (6,3)  = 2P,
\]\[
(6,3) + (5,1) = (10,6) = 3P,
\]\[
(10,6) + (5,1) = (3,1) = 4P,
\]\[
(3,1) + (5,1) = (9,16) = 5P.
\]

We, thus, find our point after four additions,
which corresponds to multiplying the point by 5.
With a group that contains $2^{256}$ elements,
this approach would not be feasible.

But how can it then be feasible 
to compute $nP$ for large $n$ in the first place?
We would need $n$ steps to produce that result
and $n$ can be a really large number.
Obviously, we need a way to perform
multiplication in significantly less than $n$ steps,
in $\log{n}$ steps, for instance.

There is indeed a way to do this.
The algorithm is quite similar to the algorithm
we used to raise a number to a huge power,
which was \term{multiply-and-square}.
Here we use a variant of that algorithm called
\term{double-and-add}, since we are dealing
with an additive group.
The algorithm may be implemented like this:

\begin{minipage}{\textwidth}
\begingroup\par\noindent\advance\leftskip\mathindent\(
\begin{pboxed}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{5}{@{}>{\hspre}l<{\hspost}@{}}%
\column{12}{@{}>{\hspre}l<{\hspost}@{}}%
\column{14}{@{}>{\hspre}l<{\hspost}@{}}%
\column{20}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[3]{}\Varid{mul}\mathbin{::}\Conid{Curve}\to \Conid{Natural}\to \Conid{Point}\to \Conid{Point}{}\<[E]%
\\
\>[3]{}\Varid{mul}\;\anonymous \;\mathrm{0}\;\anonymous {}\<[14]%
\>[14]{}\mathrel{=}\Conid{O}{}\<[E]%
\\
\>[3]{}\Varid{mul}\;\anonymous \;\anonymous \;\Conid{O}{}\<[14]%
\>[14]{}\mathrel{=}\Conid{O}{}\<[E]%
\\
\>[3]{}\Varid{mul}\;\Varid{c}\;\Varid{n}\;\Varid{p}{}\<[14]%
\>[14]{}\mathrel{=}\Varid{foldl}\;\Varid{da}\;\Varid{p}\;(\Varid{tail}\mathbin{\$}\Varid{toBinary}\;\Varid{n}){}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}\mathbf{where}\;{}\<[12]%
\>[12]{}\Varid{da}\;\Varid{q}\;\mathrm{0}{}\<[20]%
\>[20]{}\mathrel{=}\Varid{add}\;\Varid{c}\;\Varid{q}\;\Varid{q}{}\<[E]%
\\
\>[12]{}\Varid{da}\;\Varid{q}\;\mathrm{1}{}\<[20]%
\>[20]{}\mathrel{=}\Varid{add}\;\Varid{c}\;\Varid{p}\;(\Varid{add}\;\Varid{c}\;\Varid{q}\;\Varid{q}){}\<[E]%
\ColumnHook
\end{pboxed}
\)\par\noindent\endgroup\resethooks
\end{minipage}

The first base case states that
0 times anything is the identity.
Then, the identity multiplied by any number
is again the identity. The identity, indeed,
never changes with multiplication.
Just as zero would never change by multiplication
in the realm of numbers.
Any point multiplied by zero, on the other hand,
is the identity of the additive group and that, again, is zero.

In all other cases, we convert $n$ into a list
of binary digits of which we process all but the head.
For each digit, we double the intermediate result $q$,
that is we compute \ensuremath{\Varid{add}\;\Varid{c}\;\Varid{q}\;\Varid{q}}.
If the current digit is 0, we are done with this digit and continue
with the next one.
Otherwise, if it is 1, we additionally add $p$.
When there are no more digits left,
we have a result.

It is noteworthy that this implementation of multiplication
does not use the means of the arithmetic group modulo a prime
that underlies point addition. It is build on top of addition
using only terms related to the group of points on the curve,
the second layer in the sketch above.

Let us look at an example. Say, we want to
compute $19P$.
The binary representation of 19 is \ensuremath{[\mskip1.5mu \mathrm{1},\mathrm{0},\mathrm{0},\mathrm{1},\mathrm{1}\mskip1.5mu]}.
We, hence, would compute $P+P$ for the first digit 0 
(which is the head of the tail of our number).
This is $2P$. With this result we go into the next round.
The next digit is 0 again and we get $4P$,
which is the input for the next iteration.
The next digit is 1, so we double and add.
We, hence, compute $4P+4P+P = 9P$.
This is now the input to the final digit.
Since it is 1 again, we again double and add
and we have $9P+9P+P=19P$.

It works perfectly. But why does it work? Consider
the representation of a number in terms of
powers of 2 multiplied by a number $k$:

\[
k(a_r2^r + a_{r-1}2^{r-1} + \dots + a_02^0),
\]

where, for $i \in \lbrace 0\dots r\rbrace$, 
$a_i \in \lbrace 0,1\rbrace$.
Multiplying this out, we get

\[
a_r2^rk + a_{r-1}2^{r-1}k + \dots + a_02^0k.
\]

Obviously, from step to step, that is from plus sign
to plus sign, right to left, $k$ doubles. 
Ignoring the coefficients $a_i$
for a moment, that would look for the concrete number
$10011_2 = 19_{10}$ like

\[
16k + 8k + 4k + 2k + k.
\]

Doubling would in this case generate the number $16k$,
which would indeed be the correct result if the 
binary number were $10000_2$.
Now, we eliminate all terms with coefficient $a_i = 0$,
which are $8k$ and $4k$. We are left with

\[
16k + 2k + k.
\]

The value we add to $16k$ corresponds exactly
to the value of $k$ we would add with \ensuremath{\Varid{mul}}. For the example,
we would add one $k$ processing the last but one digit.
This $k$ is now part of the intermediate result, $2q+k$, that
goes into the processing of the last digit.
Processing the last digit, we double the previous result,
obtaining $4q+2k$ and, since the last digit is also 1,
we add $k$ again. We, hence, get three ``extra'' $k$s,
which we add to the overall doubling result 16 and get
$16+2+1=16+3=19$.
\section{EC Diffie-Hellman} 
\section{EC Integrated Encryption Scheme} 
\section{EC Digital Signature Algorithm} 
\section{Cryptoanalysis} 
\section{Mr. Frobenius} 
\section{Mr. Schoof} 
\section{Mr. Elkies and Mr. Aktin} 
\section{EC in Practice} 


\end{document}
